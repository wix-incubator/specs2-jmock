package com.wixpress.common.specs2.impostisers

import java.lang.invoke.{MethodHandles, MethodType}
import java.lang.reflect.{Constructor, Method}


/**
 * Invokes methods as defined in their [[getDeclaringClass]], bypassing any overrides.
 * This is useful for invoking the actual implementations of non-abstract methods of dynamyc proxies (generated by Java reflection or ByteBuddy).
 * Uses method handles and `invokespecial`.
 * Based on https://stackoverflow.com/a/58800339/10035812
 */
object SpecialMethodInvoker extends SpecialMethodInvoker {
  private val java8ClassVersion = 52
  private val javaClassVersion = System.getProperty("java.class.version").toFloat
  private val instance =
    if(javaClassVersion <= java8ClassVersion) java8Invoker
    // in some jdk11 implementations we get IllegalAccessException: "no private access for invokespecial"
    // so we fallback to the java 8 method, which only warns of "An illegal reflective access operation has occurred"
    else java9AndLaterInvoker orElse java8Invoker

  override def invoke(impl: AnyRef,
                      method: Method,
                      args: Array[AnyRef]): AnyRef = instance.invoke(impl, method, args)

  private lazy val java8Invoker = new SpecialMethodInvoker {
    override def toString: String = "SpecialMethodInvoker.java8Invoker"

    private val constructor: Constructor[MethodHandles.Lookup] =
      classOf[MethodHandles.Lookup].getDeclaredConstructor(classOf[Class[_]])
    constructor.setAccessible(true)

    override def invoke(impl: AnyRef, method: Method, args: Array[AnyRef]): AnyRef = {
      val clazz = method.getDeclaringClass
      constructor.newInstance(clazz)
        .in(clazz)
        .unreflectSpecial(method, clazz)
        .bindTo(impl)
        .invokeWithArguments(args:_*)
    }
  }

  private lazy val java9AndLaterInvoker = new SpecialMethodInvoker {
    override def toString: String = "SpecialMethodInvoker.java9AndLaterInvoker"

    override def invoke(proxy: AnyRef,
                        method: Method,
                        args: Array[AnyRef]): AnyRef = {

      // calling `MethodHandles.privateLookupIn(method.getDeclaringClass, MethodHandles.lookup)`
      // using reflection so it can be compiled under java 8
      val privateLookup = classOf[MethodHandles].getMethod("privateLookupIn", classOf[Class[_]], classOf[MethodHandles.Lookup])
        .invoke(null, method.getDeclaringClass, MethodHandles.lookup).asInstanceOf[MethodHandles.Lookup]

      privateLookup
        .findSpecial(
          method.getDeclaringClass,
          method.getName,
          MethodType.methodType(method.getReturnType, method.getParameterTypes),
          method.getDeclaringClass)
        .bindTo(proxy)
        .invokeWithArguments(args: _*)
    }
  }
}

sealed trait SpecialMethodInvoker { outer =>
  def invoke(impl: AnyRef, method: Method, args: Array[AnyRef]): AnyRef

  def orElse(that: => SpecialMethodInvoker) = new SpecialMethodInvoker {
    private lazy val fallback = that
    override def invoke(impl: AnyRef,
                        method: Method,
                        args: Array[AnyRef]): AnyRef = {
       try outer.invoke(impl, method, args)
       catch {
         case e: Throwable =>
           traceError(s"Failed to invoke $method on $impl - falling back $fallback", e)
           fallback.invoke(impl, method, args)
       }
    }
  }
}


